#define DIVISION 40
#define MAX_RADIUS 0.2
#define DEBUG(_) Cf=_; return;

vector to_space(vector xbasis, vector ybasis, vector zbasis, vector from){
    return vector(dot(xbasis, from), dot(ybasis, from), dot(zbasis, from));
}


float line(point p, float direction, float width){
    float theta = direction * M_PI;
    float k = tan(theta);
    float distance = abs(k * p[0] - p[1])/sqrt(k * k + 1);
    return 1 - step(width*0.5, distance);
}


shader scratch(
    float density=1,
    float width=0.01,
    float offset=0.25,
    output color Cf = 0
){
    float delta = 1.0/(DIVISION - 1);
    int max_search_cell = (int)ceil(MAX_RADIUS/delta);
    point index = point(round(u/delta), round(v/delta), 0.0);
    point shading_p = point(u, v , 0.0);
    point current_index;

    point current_origin_p;
    float scratch = 0, direction=0;
    for (int x = -max_search_cell; x <= max_search_cell; ++x){
        for (int y = -max_search_cell; y <= max_search_cell; ++y){
            current_index = index + point(x, y, 0);

            current_origin_p = (current_index + (hashnoise(current_index) - 0.5)) * delta;
            direction = hashnoise(current_index + vector(123, 456, 0));
            scratch = line(
            	current_origin_p - shading_p,
            	direction,
            	width * hashnoise(current_index)
            );
            if (scratch)
                break;
        }
        if (scratch)
            break; 
    }
    Cf = color(scratch, (direction * 0.5 + offset) * (scratch > 1e-4), 0);
}

