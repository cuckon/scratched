#define DIVISION 20
#define MAX_RADIUS 0.2
#define DEBUG(_) Cf=_; return;

vector to_space(vector xbasis, vector ybasis, vector zbasis, vector from){
	return vector(dot(xbasis, from), dot(ybasis, from), dot(zbasis, from));
}


float line(point p, float direction, float width){
	float theta = direction * M_PI;
	float k = tan(theta);
	float distance = abs(k * p[0] - p[1])/sqrt(k * k + 1);
	return 1 - aastep(width*0.5, distance);
}


shader scratch(
	float density=1,
	float width=0.01,
	output color Cf = 0
){
	float delta = 1.0/(DIVISION - 1);
	int max_search_cell = (int)ceil(MAX_RADIUS/delta);
	point index = point(round(u/delta), round(v/delta), 0.0);
	point shading_p = point(u, v , 0.0);

	// DEBUG(line(shading_p, 0.45, width));
	// DEBUG(index);



	point current_index;

	point current_origin_p;
	float scratch = 0;
	for (int x = -max_search_cell; x <= max_search_cell; ++x){
		for (int y = -max_search_cell; y <= max_search_cell; ++y){
			current_index = index + point(x, y, 0);

			current_origin_p = (current_index + (hashnoise(current_index) - 0.5)) * delta;


			// DEBUG(current_origin_p);
			
			
			scratch = line(
				current_origin_p - shading_p,
				hashnoise(current_index + vector(123, 456, 0)),
				width
			);
			// DEBUG(float(hashnoise(current_index + vector(123, 456, 0))));
			if (scratch>0.001)
				break;
		}
		if (scratch>0.001)
				break; 
	}
	Cf = scratch;
}

